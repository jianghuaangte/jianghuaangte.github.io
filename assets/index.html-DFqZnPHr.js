import{_ as a,c as r,a as e,b as t,e as o,d as n,w as c,r as s,o as i}from"./app-Kp0nn9So.js";const h="/images/process.jpg",g="/images/exclude.jpeg",f="/images/hangshou.jpeg",u={};function x(y,d){const l=s("VPLink");return i(),r("div",null,[d[2]||(d[2]=e('<h2 id="正则工具" tabindex="-1"><a class="header-anchor" href="#正则工具"><span>正则工具</span></a></h2><ul><li><a href="https://regex101.com/" target="_blank" rel="noopener noreferrer">正则工具(推荐)</a></li><li><a href="https://c.runoob.com/front-end/854/?optionGlobl=global" target="_blank" rel="noopener noreferrer">在线正则可视化工具</a></li><li><a href="https://www.emeditor.org/zh-cn/howto/search/search_regexp_syntax.html" target="_blank" rel="noopener noreferrer">EmEdit 正则语法</a></li></ul><h2 id="写正则的思考思路" tabindex="-1"><a class="header-anchor" href="#写正则的思考思路"><span>写正则的思考思路</span></a></h2><ul><li>必须出现</li><li>可能出现</li><li>不可能出现</li></ul><h2 id="vim-正则比较" tabindex="-1"><a class="header-anchor" href="#vim-正则比较"><span>Vim 正则比较</span></a></h2>',5)),t("p",null,[d[1]||(d[1]=o("请阅读：",-1)),n(l,{href:"regex.md"},{default:c(()=>[...d[0]||(d[0]=[o("Vim 正则表达式",-1)])]),_:1})]),d[3]||(d[3]=e('<h2 id="正则引擎" tabindex="-1"><a class="header-anchor" href="#正则引擎"><span>正则引擎</span></a></h2><p><strong>主要有三类：</strong></p><ul><li>传统型 NFA （主流）</li><li>POSIX NFA （GNU工具）</li><li>DFA</li></ul><p>这里以传统型 NFA 为主要内容。</p><h2 id="正则匹配过程" tabindex="-1"><a class="header-anchor" href="#正则匹配过程"><span>正则匹配过程</span></a></h2><p>可以把待匹配的<code>字符串</code> 想象它流水线上的产品，正则表达式相当于流水线上的挑选工人。 这里是 Perl 语法为例</p><p><img src="'+h+'" alt="process"></p><h2 id="正则术语表" tabindex="-1"><a class="header-anchor" href="#正则术语表"><span>正则术语表</span></a></h2><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">别名</th><th>子集</th></tr></thead><tbody><tr><td style="text-align:left;">零宽断言</td><td style="text-align:left;">断言/预搜索/环视/环顾/匹配边界</td><td></td></tr><tr><td style="text-align:left;">匹配优先</td><td style="text-align:left;">贪婪模式、</td><td></td></tr><tr><td style="text-align:left;">忽略优先匹配</td><td style="text-align:left;">非贪婪模式/懒惰模式</td><td></td></tr><tr><td style="text-align:left;">量词</td><td style="text-align:left;">重复/</td><td></td></tr><tr><td style="text-align:left;">字符集</td><td style="text-align:left;">字符类/字符组</td><td></td></tr></tbody></table><h2 id="编辑器的默认值" tabindex="-1"><a class="header-anchor" href="#编辑器的默认值"><span>编辑器的默认值</span></a></h2><p>很多正则编辑器如 “emeditor”、&quot;cotEditor&quot; 因为设计目录都是为以行为单位的文本服务的，所以很多都是默认开启以下修饰符：</p><ul><li>-g 全局匹配</li><li>-m 多行模式</li></ul><hr><div style="text-align:center;"><p><strong>正则主体内容：↓</strong></p></div><h2 id="普通字符" tabindex="-1"><a class="header-anchor" href="#普通字符"><span>普通字符</span></a></h2><p>即没有特殊意义的字符</p><table><thead><tr><th style="text-align:left;">字符</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">26 个字母（含大写）</td><td style="text-align:left;">普通字符按字面匹配</td></tr><tr><td style="text-align:left;">中文符号和标点</td><td style="text-align:left;">全是普通字符</td></tr><tr><td style="text-align:left;">数字</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">~</td><td style="text-align:left;">波浪行</td></tr><tr><td style="text-align:left;">~</td><td style="text-align:left;">在排除型字符内外不同</td></tr><tr><td style="text-align:left;">`</td><td style="text-align:left;">反引号</td></tr><tr><td style="text-align:left;">@</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">#</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">%</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">&amp;</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">-</td><td style="text-align:left;">如 a-z</td></tr><tr><td style="text-align:left;">_</td><td style="text-align:left;">下划线</td></tr><tr><td style="text-align:left;">=</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">]</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">;</td><td style="text-align:left;">分号</td></tr><tr><td style="text-align:left;">:</td><td style="text-align:left;">冒号</td></tr><tr><td style="text-align:left;">&quot;</td><td style="text-align:left;">双引号</td></tr><tr><td style="text-align:left;">&#39;</td><td style="text-align:left;">单引号</td></tr><tr><td style="text-align:left;">&lt;</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">&gt;</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">/</td><td style="text-align:left;">部分正则会以“/”分隔</td></tr></tbody></table><p>括号转义</p>',18)),d[4]||(d[4]=t("table",null,[t("thead",null,[t("tr",null,[t("th",{style:{"text-align":"left"}},"的"),t("th",{style:{"text-align":"left"}},"的")])]),t("tbody",null,[t("tr",null,[t("td",{style:{"text-align":"left"}},"（"),t("td",{style:{"text-align":"left"}})]),t("tr",null,[t("td",{style:{"text-align":"left"}},")"),t("td",{style:{"text-align":"left"}})]),t("tr",null,[t("td",{style:{"text-align":"left"}},"\\()"),t("td",{style:{"text-align":"left"}},"无效，必须双括号都转义")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"\\(\\)"),t("td",{style:{"text-align":"left"}})]),t("tr",null,[t("td",{style:{"text-align":"left"}}),t("td",{style:{"text-align":"left"}})]),t("tr",null,[t("td",{style:{"text-align":"left"}},"["),t("td",{style:{"text-align":"left"}})]),t("tr",null,[t("td",{style:{"text-align":"left"}},"]"),t("td",{style:{"text-align":"left"}})]),t("tr",null,[t("td",{style:{"text-align":"left"}},"\\[]"),t("td",{style:{"text-align":"left"}},"有效，但不用这个")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"\\[...\\]"),t("td",{style:{"text-align":"left"}},"有效，最好用这个写法")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"\\{"),t("td",{style:{"text-align":"left"}},"可加可不加")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"\\}"),t("td",{style:{"text-align":"left"}},"可加可不加")]),t("tr",null,[t("td",{style:{"text-align":"left"},"css-module":"."},"\\"),t("td",{style:{"text-align":"left"}},"支持，但不推荐")]),t("tr",null,[t("td",{style:{"text-align":"left"}},"\\{....\\}"),t("td",{style:{"text-align":"left"}},"推荐写法")])])],-1)),d[5]||(d[5]=e('<p>所有字符都是文字除了: &quot;.&quot;, &quot;*&quot;, &quot;?&quot;, &quot;+&quot;, &quot;(&quot;, &quot;)&quot;, &quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;, &quot;^&quot;, &quot;$&quot; 和 &quot;\\&quot;。这些字符代表文字当之前有一个 &quot;\\&quot; 时。一个文字是一个与它自己相匹配的字符。例如，搜索 &quot;\\?&quot; 会匹配每一个在文档中的 &quot;?&quot; ，或搜索 &quot;Hello&quot; 会匹配每一个在文档中的 &quot;Hello&quot; 。</p><h2 id="元字符" tabindex="-1"><a class="header-anchor" href="#元字符"><span>元字符</span></a></h2><p>即有特殊意义的字符</p><table><thead><tr><th style="text-align:left;">元字符</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left;">\\</td><td>把下一个字符标记为一个特殊字符，一个文字，或一个向后引用。例如，&#39;n&#39; 与字符 &quot;n&quot; 相匹配。而 &#39;\\n&#39; 代表一个换行符号。序列 &#39;\\\\&#39; 代表 &quot;\\&quot;，&quot;\\(&quot; 则与 &quot;(&quot; 相匹配。</td><td></td></tr><tr><td style="text-align:left;">^</td><td>匹配输入字符串的开始位置。例如，&quot;^e&quot; 表示任何由 &quot;e&quot; 开头的字符串。</td><td></td></tr><tr><td style="text-align:left;">$</td><td>匹配输入字符串的结尾位置。例如，&quot;e$&quot; 表示任何由 &quot;e&quot; 结尾的字符串。</td><td></td></tr><tr><td style="text-align:left;">*</td><td>匹配之前的字符或子表达式零次或多次。例如，zo* 会匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等同于 {0,}。</td><td></td></tr><tr><td style="text-align:left;">+</td><td>匹配之前的字符或子表达式一次或多次。例如，&#39;zo+&#39; 匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不匹配 &quot;z&quot;。 + 等同于 {1,}。</td><td></td></tr><tr><td style="text-align:left;">?</td><td>匹配之前的字符或子表达式零次或一次。例如，&quot;do(es)?&quot; 匹配 &quot;do&quot; 在  &quot;do&quot; 或 &quot;does&quot; 中。? 等同于 {0,1}。</td><td></td></tr><tr><td style="text-align:left;">?</td><td>当这个字符紧跟着任何其他数量词 (*, +, ?, {n}, {n,}, {n,m}) 时，匹配的模式是非贪婪。一个非贪婪模式尽可能少地与搜索字符串匹配，而默认的贪婪模式则尽可能多地与搜索字符串匹配。例如，字符串 &quot;oooo&quot;，&#39;o+?&#39; 匹配单一的一个 &quot;o&quot;，而w &#39;o+&#39; 匹配所有 &#39;o&#39;。</td><td></td></tr><tr><td style="text-align:left;">.</td><td>与任何单一字符串匹配。例如，&quot;.e&quot; 匹配任何在 &quot;e&quot; 之前的文字，如 &quot;he&quot;，&quot;we&quot;，或 &quot;me&quot;。<br><br>在 EmEditor Professional 中，它匹配 <strong>搜索正则表达式的附近行</strong> 文本框中指定范围内的换行当 <strong>正则表达式 &quot;.&quot; 匹配换行符</strong> 复选框被勾选。</td><td></td></tr></tbody></table><h2 id="字符组" tabindex="-1"><a class="header-anchor" href="#字符组"><span>字符组</span></a></h2><ul><li><strong>也叫“字符集”</strong></li></ul><table><thead><tr><th style="text-align:left;">形式</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">[xyz]<br></td><td style="text-align:left;">字符集。匹配任何在括号内的字符。例如，&#39;[abc]&#39; 与 &quot;plain&quot; 中的 &#39;a&#39; 相匹配。</td></tr><tr><td style="text-align:left;">[^xyz]<br></td><td style="text-align:left;">负字符集。匹配任何不在括号内的字符。例如，[^abc]&#39; 与 &quot;plain&quot; 中的 &#39;p&#39; 相匹配。</td></tr><tr><td style="text-align:left;">[a-z]</td><td style="text-align:left;">字符范围。与任何指定范围的字符相匹配。例如，&#39;[a-z]&#39; 与任何 &#39;a&#39; 到 &#39;z&#39; 的小写字母相匹配。</td></tr><tr><td style="text-align:left;">[^a-z]</td><td style="text-align:left;">负字符范围。与任何不在指定范围内的字符相匹配。例如，&#39;[a-z]&#39; 与任何不在 &#39;a&#39; 到 &#39;z&#39; 范围内的字符相匹配。</td></tr></tbody></table><h3 id="普通字符组" tabindex="-1"><a class="header-anchor" href="#普通字符组"><span>普通字符组</span></a></h3><p>一般使用 Unicode 或 ASICC 编码顺序设置范围，如[a-z]、[0-9]</p><h3 id="简写字符组" tabindex="-1"><a class="header-anchor" href="#简写字符组"><span>简写字符组</span></a></h3><p>正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr><th style="text-align:center;">简写</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">.</td><td>除换行符外的所有字符</td></tr><tr><td style="text-align:center;">\\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td style="text-align:center;">\\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\\w]</code></td></tr><tr><td style="text-align:center;">\\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td style="text-align:center;">\\D</td><td>匹配非数字： <code>[^\\d]</code></td></tr><tr><td style="text-align:center;">\\s</td><td>匹配所有空格字符，等同于： <code>[\\t\\n\\f\\r\\p{Z}]</code></td></tr><tr><td style="text-align:center;">\\S</td><td>匹配所有非空格字符： <code>[^\\s]</code></td></tr><tr><td style="text-align:center;">\\f</td><td>匹配一个换页符</td></tr><tr><td style="text-align:center;">\\n</td><td>匹配一个换行符</td></tr><tr><td style="text-align:center;">\\r</td><td>匹配一个回车符</td></tr><tr><td style="text-align:center;">\\t</td><td>匹配一个制表符</td></tr><tr><td style="text-align:center;">\\v</td><td>匹配一个垂直制表符</td></tr><tr><td style="text-align:center;">\\p</td><td>匹配 CR/LF（等同于 <code>\\r\\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><hr><h3 id="字符组的字符位置" tabindex="-1"><a class="header-anchor" href="#字符组的字符位置"><span>字符组的字符位置</span></a></h3><p><strong>正则表达式里的 <code>[]</code>（字符组）中，有些符号在不同位置会有不同的意义</strong></p><ul><li>不同位置上的 <code>-</code>（连字符）</li></ul><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>[a-z]</code></td><td>匹配 <code>a</code> 到 <code>z</code> 之间的任意小写字母（<strong>范围</strong>）</td></tr><tr><td><code>[-az]</code> 或 <code>[az-]</code></td><td><code>-</code> 在<strong>开头或结尾</strong> → 被视为<strong>普通字符 <code>-</code></strong></td></tr><tr><td><code>[a\\-z]</code></td><td><code>\\</code> 转义后表示<strong>字面量 <code>-</code></strong></td></tr><tr><td><code>[a-z-]</code></td><td>匹配 <code>a</code>~<code>z</code> 以及 <code>-</code></td></tr><tr><td><code>[a-b-c]</code></td><td>通常解析为 <code>[a-c]</code>（即 <code>a</code> 到 <code>c</code>），但在不同实现中可能会被认为是两个范围重叠（不推荐）</td></tr></tbody></table><p>✅ <strong>结论</strong>：<br> 在字符组中，<code>-</code> 只有当它位于两个字符之间（例如 <code>a-z</code>）时才表示<strong>范围</strong>；<br> 位于开头、结尾或被转义时，表示字面字符。</p><hr><ul><li>不同位置上的<code>^</code>（脱字符）</li></ul><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>[^a-z]</code></td><td>在<strong>开头</strong>表示<strong>取反（否定）</strong>，匹配除小写字母外的任何<code>字符</code>（必须匹配一个字符）</td></tr><tr><td><code>[a^z]</code></td><td>不在开头时表示<strong>字面量 <code>^</code></strong></td></tr></tbody></table><p>✅ <strong>结论</strong>：<br><code>^</code> 只有在 <code>[</code> 后<strong>紧跟出现</strong>时才有特殊意义（表示<strong>取反</strong>），否则就是普通字符</p><p>特别说明：<strong>排除型字符组被排除的位置<code>必须</code>占一个字符</strong><br> 它无法匹配 <code>Iraq</code> 因为<code>q</code>后面没有字符</p><img src="'+g+`" width="400"><ul><li>不同位置上的 <code>]</code>（右方括号）</li></ul><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>[]]</code></td><td>匹配 <code>]</code> 本身（第一个 <code>]</code> 结束字符组，第二个是内容）→ 一般匹配 <code>]</code></td></tr><tr><td><code>[a\\]]</code></td><td>转义后表示字面量 <code>]</code></td></tr><tr><td><code>[a]]</code></td><td>一些实现中等价于（或强制转义） <code>[a\\]]</code>（第二个 <code>]</code> 当作普通字符）</td></tr></tbody></table><p>✅ <strong>结论</strong>：<br><code>]</code> 如果出现在<strong>字符组开头</strong>（如 <code>[]a]</code> 或 <code>[a]]</code>）或<strong>被转义</strong>，就表示普通 <code>]</code>。</p><hr><ul><li>不同位置上的 <code>[</code> （右中括号）</li></ul><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>[[a-z]]</code></td><td>内层的 <code>[</code> 被视为字面量</td></tr><tr><td><code>[\\[]</code></td><td>明确转义表示 <code>[</code></td></tr></tbody></table><p>✅ <strong>结论</strong>：<br><code>[</code> 一般只需转义或放在特殊位置（如首位）即可表示字面意义。</p><hr><ul><li>不同位置上的 <code>\\</code>（反斜杠）</li></ul><table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>[a\\-z]</code></td><td>转义后表示 <code>-</code></td></tr><tr><td><code>[\\\\]</code></td><td>匹配反斜杠本身</td></tr><tr><td><code>[\\\\-]</code></td><td>匹配反斜杠或 <code>-</code></td></tr></tbody></table><p>✅ <strong>结论</strong>：<br><code>\\</code> 在字符组中通常仍保留转义意义，但<strong>不同语言实现略有差异</strong>。<br> （例如 POSIX 中 <code>[\\\\]</code> 匹配 <code>\\</code>，但某些简化版不支持。）</p><hr><h2 id="量词" tabindex="-1"><a class="header-anchor" href="#量词"><span>量词</span></a></h2><ul><li>注意，<strong>量词会创建回溯点</strong></li></ul><h3 id="量词分类" tabindex="-1"><a class="header-anchor" href="#量词分类"><span>量词分类</span></a></h3><table><thead><tr><th>分类</th><th>名称</th><th>特征</th><th>回溯</th><th>示例</th></tr></thead><tbody><tr><td>①</td><td><strong>贪婪量词</strong></td><td><strong>匹配尽可能多</strong></td><td>✅ 可回溯</td><td><code>.*</code></td></tr><tr><td>②</td><td><strong>惰性量词</strong></td><td><strong>匹配尽可能少</strong></td><td>✅ 可回溯</td><td><code>.*?</code></td></tr><tr><td>③</td><td><strong>占有量词</strong></td><td><strong>匹配尽可能多，但不回溯</strong></td><td>❌ 不回溯</td><td><code>.*+</code></td></tr><tr><td>④</td><td><strong>固定次数量词</strong></td><td>匹配确定次数</td><td>无需回溯</td><td><code>a{3}</code></td></tr><tr><td>⑤</td><td><strong>区间量词</strong></td><td>指定最小 / 最大次数</td><td>✅（可与惰性/占有结合）</td><td><code>a{2,5}</code>、<code>a{2,5}?</code>、<code>a{2,5}+</code></td></tr></tbody></table><hr><h3 id="区间量词" tabindex="-1"><a class="header-anchor" href="#区间量词"><span>区间量词</span></a></h3><table><thead><tr><th>语法</th><th>说明</th><th>等价形式</th></tr></thead><tbody><tr><td><code>{n}</code></td><td>匹配恰好 n 次</td><td>固定</td></tr><tr><td><code>{n,}</code></td><td>至少 n 次</td><td>类似 <code>patternpattern*</code></td></tr><tr><td><code>{,m}</code></td><td>0 到 m 次</td><td>旧 Perl 不支持此省略写法</td></tr><tr><td><code>{n,m}</code></td><td>n 到 m 次</td><td>可结合惰性或占有后缀</td></tr></tbody></table><hr><h3 id="匹配优先量词" tabindex="-1"><a class="header-anchor" href="#匹配优先量词"><span>匹配优先量词</span></a></h3><p>也叫贪婪模式匹配</p><table><thead><tr><th>语法</th><th>名称</th><th>行为</th><th>示例</th><th>匹配策略说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>零次或多次</td><td><strong>尽可能多匹配</strong>，必要时回溯</td><td><code>/a*b/</code></td><td>匹配 <code>aaab</code> 中的 <code>aaa</code>（多 → 少回溯）</td></tr><tr><td><code>+</code></td><td>一次或多次</td><td><strong>尽可能多匹配</strong>，必要时回溯</td><td><code>/a+b/</code></td><td>匹配 <code>aaab</code> 中的 <code>aaa</code></td></tr><tr><td><code>?</code></td><td>零次或一次</td><td><strong>尽可能多匹配一次</strong></td><td><code>/a?b/</code></td><td>匹配 <code>ab</code> 或仅 <code>b</code></td></tr><tr><td><code>{n}</code></td><td>恰好 n 次</td><td>固定匹配 n 次，无回溯</td><td><code>/a{3}/</code></td><td>匹配 <code>aaa</code></td></tr><tr><td><code>{n,}</code></td><td>至少 n 次</td><td>尽可能多匹配，必要时回溯</td><td><code>/a{2,}/</code></td><td>匹配 2 次起</td></tr><tr><td><code>{n,m}</code></td><td>n 到 m 次</td><td>尽可能多匹配，必要时回溯</td><td><code>/a{2,4}/</code></td><td>匹配 2~4 个 <code>a</code>，优先 4</td></tr></tbody></table><hr><h3 id="忽略优先量词" tabindex="-1"><a class="header-anchor" href="#忽略优先量词"><span>忽略优先量词</span></a></h3><p>也叫惰性（非贪婪）量词</p><table><thead><tr><th>语法</th><th>含义</th><th>匹配策略</th><th>示例匹配 <code>&quot;aaaa&quot;</code></th></tr></thead><tbody><tr><td><code>*?</code></td><td>尽可能少（0~n）</td><td>先尝试最少，再回溯增加</td><td><code>a*?</code> → <code>&quot;&quot;</code>（空匹配）</td></tr><tr><td><code>+?</code></td><td>尽可能少（1~n）</td><td>最小满足匹配</td><td><code>a+?</code> → <code>&quot;a&quot;</code></td></tr><tr><td><code>??</code></td><td>尽可能少（0 或 1）</td><td>优先匹配 0 次</td><td><code>a??</code> → <code>&quot;&quot;</code></td></tr><tr><td><code>{n,}?</code></td><td>匹配至少 n 次，尽量少</td><td></td><td><code>a{2,}?</code> → <code>&quot;aa&quot;</code></td></tr><tr><td><code>{n,m}?</code></td><td>匹配 n~m 次，尽量少</td><td></td><td><code>a{2,3}?</code> → <code>&quot;aa&quot;</code></td></tr></tbody></table><p>🧠 <strong>行为特点</strong>：<strong>先尝试最少可能匹配</strong>，如不满足则回溯扩张</p><hr><h3 id="占有量词" tabindex="-1"><a class="header-anchor" href="#占有量词"><span>占有量词</span></a></h3><table><thead><tr><th>语法</th><th>含义</th><th>行为</th><th>回溯</th><th>示例匹配 <code>&quot;aaaa&quot;</code></th></tr></thead><tbody><tr><td><code>*+</code></td><td>0 到任意多次，占有</td><td>一次性吃光，绝不回头</td><td>❌</td><td><code>a*+b</code> 不匹配 <code>&quot;aaaaab&quot;</code>（因为不回退）</td></tr><tr><td><code>++</code></td><td>1 到任意多次，占有</td><td>同上</td><td>❌</td><td></td></tr><tr><td><code>?+</code></td><td>0 或 1，占有</td><td>同上</td><td>❌</td><td></td></tr><tr><td><code>{n,}+</code></td><td>至少 n，占有</td><td>同上</td><td>❌</td><td></td></tr><tr><td><code>{n,m}+</code></td><td>n~m，占有</td><td>同上</td><td>❌</td><td></td></tr></tbody></table><hr><h3 id="量词总结" tabindex="-1"><a class="header-anchor" href="#量词总结"><span>量词总结</span></a></h3><table><thead><tr><th>类型</th><th>写法</th><th>匹配策略</th><th>回溯行为</th><th>常见用途</th></tr></thead><tbody><tr><td>贪婪</td><td><code>*</code>、<code>+</code>、<code>{n,m}</code></td><td>尽量多</td><td>✅ 可回溯</td><td>默认模式</td></tr><tr><td>惰性</td><td><code>*?</code>、<code>+?</code>、<code>{n,m}?</code></td><td>尽量少</td><td>✅ 可回溯</td><td>避免过度吞噬</td></tr><tr><td>占有</td><td><code>*+</code>、<code>++</code>、<code>{n,m}+</code></td><td>尽量多</td><td>❌ 不回溯</td><td>优化性能、防止灾难回溯</td></tr></tbody></table><p>📘 <strong>机制说明</strong>：</p><ul><li>贪婪：匹配尽量多，如失败则回溯减少；</li><li>占有：匹配尽量多，但<strong>不允许</strong>回溯；</li><li>惰性：匹配尽量少，如失败则回溯增加。</li></ul><p>注意点</p><table><thead><tr><th style="text-align:left;">正则</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left;">.*</td><td>它可以匹配空字符，也就是可以不匹配任何字符</td></tr><tr><td style="text-align:left;">位置替换</td><td>匹配位置（锚点）是可以替换的，如 正则：<code>/(a)?/k/g</code> ，字符串：aaabbb，结果：kkkbkbkbk</td></tr></tbody></table><h2 id="多选分支" tabindex="-1"><a class="header-anchor" href="#多选分支"><span>多选分支</span></a></h2><table><thead><tr><th style="text-align:left;">形式</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">x|y</td><td style="text-align:left;">与 x 或 y 向匹配。例如，&#39;z|food&#39; 与 &quot;z&quot; 或 &quot;food&quot; 匹配。&#39;(z|f)ood&#39; 与 &quot;zood&quot; 或 &quot;food&quot; 匹配。</td></tr></tbody></table><ul><li>多选结构的形式是<code>（...|...）</code>，在括号内以竖线<code>|</code>分隔开多个子表达式，这些子表达式也叫多选分支 ；在一个多选结构内，多选分支的数目没有限制</li><li>在多选结构中一般会同时使用括号（）和竖线|；但是如果没有括号（），只出现竖线|，仍然是多选结构</li><li><strong>会创建回溯点</strong></li></ul><p>注意 “|” 和 [...] 都可以表示或的意思，但 | 把多个字符当成整体，而 [...] 是单个字符</p><h3 id="顺序" tabindex="-1"><a class="header-anchor" href="#顺序"><span>顺序</span></a></h3><p>例：(option1|option2)，(jeff|jeffrey)用它匹配 <code>jeffrey</code>, 结果到底是 <code>jeff</code> 还是 <code>jeffrey</code> 呢 结果是 <code>jeff</code>，因为最左边的优先匹配</p><hr><h2 id="转义" tabindex="-1"><a class="header-anchor" href="#转义"><span>转义</span></a></h2><p>转义使用 <code>\\</code></p><h3 id="控制字符-字符类转义" tabindex="-1"><a class="header-anchor" href="#控制字符-字符类转义"><span>控制字符 / 字符类转义</span></a></h3><table><thead><tr><th>转义序列</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>\\t</code></td><td>制表符 Tab</td><td>0x09</td></tr><tr><td><code>\\n</code></td><td>换行符 LF</td><td>0x0A</td></tr><tr><td><code>\\r</code></td><td>回车符 CR</td><td>0x0D</td></tr><tr><td><code>\\f</code></td><td>换页符 FF</td><td>0x0C</td></tr><tr><td><code>\\v</code></td><td>垂直制表符 VT</td><td>0x0B</td></tr><tr><td><code>\\a</code></td><td>响铃 (Bell)</td><td>很少支持，Perl 支持</td></tr><tr><td><code>\\e</code></td><td>Escape (ESC)</td><td>常见于 Perl / PCRE</td></tr></tbody></table><hr><h3 id="为什么会有4个" tabindex="-1"><a class="header-anchor" href="#为什么会有4个"><span>为什么会有4个 <code>\\</code></span></a></h3><p>一般在底层<code>写代码</code>时要把“字符串”转义为编译器识别的“字符串”，编译器还要把已经过1次转换的“字符串”转换为正则支持的“字符串”，再由正则引擎翻译“字符串”。</p><ul><li>每一层（代码语言 → 正则引擎）都会吃掉一层 <code>\\</code></li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-txt"><span class="line"><span>你写在代码里的 &quot;语言&quot;</span></span>
<span class="line"><span>↓（第一层翻译）</span></span>
<span class="line"><span>编译器看到的 &quot;正则表达式&quot;</span></span>
<span class="line"><span>↓（第二层翻译）</span></span>
<span class="line"><span>正则引擎理解的 “匹配规则”</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：这里实际上只有在写代码时才会用到4个<code>\\</code>，而用户使用的正则工具是已经经过翻译过的了。所以正则里不可能出现4个<code>\\</code>只会出现在写代码时。</p><hr><h3 id="正则转义为纯文本" tabindex="-1"><a class="header-anchor" href="#正则转义为纯文本"><span>正则转义为纯文本</span></a></h3><p>使用 <code>\\Q...\\E</code> 包裹的正则可以把所有正则当成普通字符</p><h2 id="括号" tabindex="-1"><a class="header-anchor" href="#括号"><span>括号</span></a></h2><p>括号有三个作用：分组、多选结构、引用分组</p><h3 id="分组" tabindex="-1"><a class="header-anchor" href="#分组"><span>分组</span></a></h3><table><thead><tr><th>语法</th><th>名称</th><th>是否捕获</th><th>是否影响优先级</th><th>特点 / 用途</th></tr></thead><tbody><tr><td><code>( … )</code></td><td><strong>捕获分组</strong></td><td>✅</td><td>✅</td><td>最常见的分组方式，保存匹配内容到编号组 <code>$1</code>、<code>$2</code> 等</td></tr><tr><td><code>(?: … )</code></td><td><strong>非捕获分组</strong></td><td>❌</td><td>✅</td><td>只用于分组，不保存匹配结果</td></tr><tr><td><code>(?&lt;name&gt; … )</code> / <code>(?&#39;name&#39; … )</code></td><td><strong>命名捕获分组</strong></td><td>✅（命名）</td><td>✅</td><td>用 <code>$+{name}</code> / <code>%+</code> 访问，替代编号组</td></tr></tbody></table><h3 id="量词作用范围" tabindex="-1"><a class="header-anchor" href="#量词作用范围"><span>量词作用范围</span></a></h3><p>如： (abc)? 量词<code>?</code>作用于<code>整个 (...)</code> 里的内容</p><h3 id="反向引用" tabindex="-1"><a class="header-anchor" href="#反向引用"><span>反向引用</span></a></h3><table><thead><tr><th style="text-align:left;">形式</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">\\1 - \\9</td><td style="text-align:left;">指定一个向后引用 - 一个向后引用是上一个被匹配的子表达式的引用。引用的内容是与子表达式相匹配的内容，而不是表达式本身。一个向后引用由转义符 &quot;\\&quot; 加一个 &quot;1&quot; 到 &quot;9&quot; 的数字组成。&quot;\\1&quot; 指的是第一个子表达式，&quot;\\2&quot; 是第 2 个，以此类推。例如，&quot;(a)\\1&quot; 会捕捉 &quot;a&quot; 为第一个向后引用，并匹配任何 &quot;aa&quot; 文本。你还可以使用向后引用功能当你在 <strong>搜索</strong> 菜单下选择 <strong>替换</strong> 功能时。用正则表达式来定位一个文本格式，与之相匹配的文本能被一个指定的向后引用替换。例如，&quot;(h)(e)&quot; 的表达式会在文本中查找 &quot;he&quot;，把 &quot;\\1&quot; 放在 <strong>替换为</strong> 文本框中会用 &quot;h&quot; 取代 &quot;he&quot;， 而如果是 &quot;\\2\\1&quot; 的话，则会用 &quot;eh&quot; 取代 &quot;he&quot; 。</td></tr><tr><td style="text-align:left;">\\k</td><td style="text-align:left;">表示一个已命名的向后引用。已命名的向后引用是用以下形式引用之前匹配的已命名的捕获组：(?expression)。如果 &quot;name&quot; 是一个数字，则它表示一个已编号的向后引用，相当于 \\1，\\2，\\3，...。</td></tr></tbody></table><p>使用 <code>\\1</code> 引用被捕获的组内容</p><ul><li>注意：最大支持\\9，超过要用命名分组</li><li>嵌套括号的引用顺序是依据开括号出现的先后顺序决定</li><li>非捕获分组不计数</li><li>也有的工具用用<code>$1</code>，根本原因是工具和编程语言的不同</li></ul><h3 id="嵌套括号" tabindex="-1"><a class="header-anchor" href="#嵌套括号"><span>嵌套括号</span></a></h3><p>(a(b))c <strong>遇到第一个左括号时分配编号</strong>（从1开始） <strong>采用深度优先（depth-first）+ 从左到右</strong> 的顺序</p><ul><li>也就是最内部的括号对优先级比外面的高</li></ul><h3 id="优先级" tabindex="-1"><a class="header-anchor" href="#优先级"><span>优先级</span></a></h3><p><strong>正则表达式从左到右进行计算，并遵循优先级顺序</strong></p><h2 id="锚点" tabindex="-1"><a class="header-anchor" href="#锚点"><span>锚点</span></a></h2><p>锚点是匹配位置的一种。</p><p><code>\\A</code>、<code>\\Z</code>、<code>\\z</code> 是<strong>定位锚点（anchors）</strong>，但它们比常见的 <code>^</code> 和 <code>$</code> <strong>更严格、更精确</strong></p><table><thead><tr><th>锚点</th><th>匹配位置</th><th>是否受 <code>/m</code> 多行模式影响</th><th>特点</th></tr></thead><tbody><tr><td><code>^</code></td><td>行首（或字符串开头）</td><td>✅ 是</td><td>可匹配每行开头（开启 <code>/m</code> 时）</td></tr><tr><td><code>$</code></td><td>行尾（或字符串结尾，或结尾前的 <code>\\n</code>）</td><td>✅ 是</td><td>可匹配行尾或字符串结尾</td></tr><tr><td><code>\\A</code></td><td>仅字符串开头</td><td>❌ 否</td><td><strong>绝对开头</strong>，不受 <code>/m</code> 影响</td></tr><tr><td><code>\\Z</code></td><td>字符串结尾，或结尾前的换行符前</td><td>❌ 否</td><td><strong>几乎等价于 <code>$</code></strong>，但不受 <code>/m</code></td></tr><tr><td><code>\\z</code></td><td>严格的字符串结尾（最后一个字符后）</td><td>❌ 否</td><td><strong>比 <code>\\Z</code> 更严格</strong></td></tr></tbody></table><p>注意：很多编辑器都是默认开启 -m（多行模式）和 -g 全局匹配的，请参见&quot;<a href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">编辑器的默认值</a>&quot; <img src="`+f+'" width="350"></p><ul><li>记忆方式：<code>\\z</code> 比<code>\\Z</code> 小，应该在 <code>\\n</code> 之前</li></ul><h2 id="断言-环视" tabindex="-1"><a class="header-anchor" href="#断言-环视"><span>断言/环视</span></a></h2><p>也是是匹配位置的一种</p><h3 id="单词边界符-数字边界符" tabindex="-1"><a class="header-anchor" href="#单词边界符-数字边界符"><span>单词边界符/数字边界符</span></a></h3><ul><li>如期望匹配的“单词” 包含在另一个单词之中</li><li>它也能匹配数字的边界</li></ul><table><thead><tr><th>符号</th><th>名称</th><th>含义</th><th>等价条件 / 匹配位置</th><th>说明</th></tr></thead><tbody><tr><td><code>\\b</code></td><td><strong>单词边界 (word boundary)</strong></td><td>单词字符 <code>\\w</code> 与 非单词字符 <code>\\W</code>（或字符串起始/结尾）之间的位置</td><td>位置左边和右边<strong>一个是 <code>\\w</code>，一个不是</strong></td><td>零宽断言，不消耗字符</td></tr><tr><td><code>\\B</code></td><td><strong>非单词边界 (non-word boundary)</strong></td><td>不在单词边界上</td><td>左右两边要么都为 <code>\\w</code>，要么都为 <code>\\W</code></td><td>常用来反转 <code>\\b</code> 的逻辑</td></tr></tbody></table><ul><li>部分流派使用 <code>\\&lt;</code> 和 <code>\\&gt;</code></li></ul><h3 id="环视" tabindex="-1"><a class="header-anchor" href="#环视"><span>环视</span></a></h3><p>注意断言的匹配和整体匹配的关系</p><table><thead><tr><th>类型</th><th>语法</th><th>含义</th><th>举例</th><th>示例匹配</th></tr></thead><tbody><tr><td><strong>正向先行断言</strong></td><td><code>(?=...)</code></td><td>当前位置 <strong>之后</strong> 必须满足 <code>...</code></td><td><code>foo(?=bar)</code></td><td>匹配 <code>&quot;foo&quot;</code>，仅当后面紧跟 <code>&quot;bar&quot;</code> 时</td></tr><tr><td><strong>负向先行断言</strong></td><td><code>(?!...)</code></td><td>当前位置 <strong>之后</strong> 必须 <strong>不满足</strong> <code>...</code></td><td><code>foo(?!bar)</code></td><td>匹配 <code>&quot;foo&quot;</code>，仅当后面 <strong>不是</strong> <code>&quot;bar&quot;</code> 时</td></tr><tr><td><strong>正向后行断言</strong></td><td><code>(?&lt;=...)</code></td><td>当前位置 <strong>之前</strong> 必须满足 <code>...</code></td><td><code>(?&lt;=foo)bar</code></td><td>匹配 <code>&quot;bar&quot;</code>，仅当前面紧跟 <code>&quot;foo&quot;</code> 时</td></tr><tr><td><strong>负向后行断言</strong></td><td><code>(?&lt;!...)</code></td><td>当前位置 <strong>之前</strong> 必须 <strong>不满足</strong> <code>...</code></td><td><code>(?&lt;!foo)bar</code></td><td>匹配 <code>&quot;bar&quot;</code>，仅当前面 <strong>不是</strong> <code>&quot;foo&quot;</code> 时</td></tr></tbody></table><p><strong>特征</strong></p><table><thead><tr><th>特征</th><th>说明</th></tr></thead><tbody><tr><td><strong>零宽匹配</strong></td><td>不消耗字符，只检查位置是否合法。匹配后，指针仍在原位置。</td></tr><tr><td><strong>可以嵌套</strong></td><td>可以在环视内部再嵌套其他环视。</td></tr><tr><td><strong>可以与分组、量词组合</strong></td><td>但量词仅作用于环视整体，不作用于内部内容。</td></tr><tr><td><strong>左右方向不同</strong></td><td><code>(?=...)</code> / <code>(?!...)</code> 从当前位置向右看，<code>(?&lt;=...)</code> / <code>(?&lt;!...)</code> 从当前位置向左看。</td></tr><tr><td><strong>后行断言长度限制</strong></td><td>Perl / PCRE 要求 <code>(?&lt;=...)</code> 内的模式长度必须可确定（固定长度）。例如 `(?&lt;=ab</td></tr><tr><td><strong>性能</strong></td><td>环视属于零宽结构，但会引入大量回溯点，特别是嵌套环视时要注意性能问题。</td></tr></tbody></table><p><strong>嵌套与优先级要点</strong></p><ol><li><p><strong>嵌套允许</strong><br> 如：<code>(?&lt;=foo(?=bar))baz</code><br> → “baz” 前必须有 “foo”，而且 “foo” 后面必须跟 “bar”。</p></li><li><p><strong>嵌套解析顺序</strong><br> 环视是从外向内解析的，但匹配时按逻辑从内层条件返回结果判断外层是否成立。</p></li><li><p><strong>量词注意</strong><br> 不能对环视内部模式使用无法确定长度的量词（尤其是后行断言）。</p></li><li><p><strong>回溯行为</strong><br> 环视自身不消耗字符，但内部模式仍可发生回溯。<br> 比如：(?=a.<em>b) 内部会对 .</em> 部分产生回溯点。 <code>*</code></p></li></ol><hr><h2 id="unicode" tabindex="-1"><a class="header-anchor" href="#unicode"><span>Unicode</span></a></h2><p>在 Unicode 下<code>.</code>不等于“一个字符” 等等...内容这里不再写</p><h2 id="修饰符" tabindex="-1"><a class="header-anchor" href="#修饰符"><span>修饰符</span></a></h2><p>在正则尾的也叫<code>匹配模式</code>，另一个在正则内的叫<code>内联修饰符</code></p><h3 id="匹配模式" tabindex="-1"><a class="header-anchor" href="#匹配模式"><span>匹配模式</span></a></h3><p>两种修饰符，</p><ul><li>一种是形如：/foo/bar/igm</li><li>一种是形如：/(?igm)foo/bar/</li></ul><h3 id="内联修饰符" tabindex="-1"><a class="header-anchor" href="#内联修饰符"><span>内联修饰符</span></a></h3><p><strong>即正则内控制模式的修饰符</strong></p><table><thead><tr><th>写法</th><th>位置</th><th>作用范围</th><th>示例</th></tr></thead><tbody><tr><td><code>(?i)</code></td><td>出现在正则最前面</td><td>全局（整个表达式）</td><td><code>(?i)abc</code> 匹配 <code>ABC</code>、<code>abc</code> 等</td></tr><tr><td><code>(?i:...)</code></td><td>在括号内带冒号</td><td>局部（只影响括号内部）</td><td><code>(?i:abc)d</code> 中只有 <code>abc</code> 大小写不敏感</td></tr><tr><td><code>(?-i)</code></td><td>取消修饰符</td><td>可以全局或局部</td><td><code>(?-i:abc)</code> 强制区分大小写</td></tr><tr><td>✅ 修饰符作用于“当前组及其子组”（嵌套括号也一样）。作用的范围不同。</td><td></td><td></td><td></td></tr></tbody></table><hr><table><thead><tr><th style="text-align:left;">修饰符</th><th style="text-align:left;">功能</th><th style="text-align:left;">是否可局部</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>i</code></td><td style="text-align:left;">忽略大小写</td><td style="text-align:left;">✅</td><td style="text-align:left;"><code>(?i)</code> 或 <code>(?i:abc)</code></td></tr><tr><td style="text-align:left;"><code>g</code></td><td style="text-align:left;">全局匹配</td><td style="text-align:left;">✅</td><td style="text-align:left;">从上一次匹配的结尾继续匹配</td></tr><tr><td style="text-align:left;"><code>m</code></td><td style="text-align:left;">多行模式，<code>^</code> 和 <code>$</code> 匹配行首行尾</td><td style="text-align:left;">✅</td><td style="text-align:left;">影响锚点匹配行为</td></tr><tr><td style="text-align:left;"><code>s</code></td><td style="text-align:left;">单行模式，让所有字符连成单行。让 <code>.</code> 匹配换行符。</td><td style="text-align:left;">✅</td><td style="text-align:left;">默认 <code>.</code> 不匹配 <code>\\n</code></td></tr><tr><td style="text-align:left;"><code>x</code></td><td style="text-align:left;">忽略空白并允许 <code>#</code> 注释</td><td style="text-align:left;">✅</td><td style="text-align:left;">方便可读性（可多行）</td></tr><tr><td style="text-align:left;"><code>U</code></td><td style="text-align:left;">反转量词默认行为（非贪婪）</td><td style="text-align:left;">✅</td><td style="text-align:left;"><code>*</code> 默认变懒惰</td></tr><tr><td style="text-align:left;"><code>d</code></td><td style="text-align:left;"><code>$</code> 仅匹配文本末尾（不匹配换行前）</td><td style="text-align:left;">✅</td><td style="text-align:left;">控制 <code>$</code> 行为</td></tr><tr><td style="text-align:left;"><code>J</code></td><td style="text-align:left;">允许重复命名捕获组</td><td style="text-align:left;">✅</td><td style="text-align:left;">否则重复命名报错</td></tr><tr><td style="text-align:left;"><code>n</code></td><td style="text-align:left;">禁用所有捕获组（隐含为非捕获）</td><td style="text-align:left;">✅</td><td style="text-align:left;">等价于每个 <code>( )</code> 都是 <code>(?: )</code></td></tr><tr><td style="text-align:left;"><code>u</code></td><td style="text-align:left;">启用 Unicode 模式（UTF 匹配）</td><td style="text-align:left;">✅</td><td style="text-align:left;">在 UTF 模式下默认开启</td></tr><tr><td style="text-align:left;"><code>D</code></td><td style="text-align:left;"><code>$</code> 不匹配行尾前的换行符</td><td style="text-align:left;">✅</td><td style="text-align:left;">与 <code>d</code> 等价（别名）</td></tr></tbody></table><ul><li>单行模式影响的是<code>.</code>的匹配规则</li><li>多行模式影响的是<code>^</code>和 <code>$</code> 的匹配规则</li></ul><hr><table><thead><tr><th style="text-align:left;">写法</th><th style="text-align:left;">含义</th><th style="text-align:left;">作用范围</th></tr></thead><tbody><tr><td style="text-align:left;"><code>(?i)</code></td><td style="text-align:left;">设置全局忽略大小写</td><td style="text-align:left;">从当前位置到表达式末尾</td></tr><tr><td style="text-align:left;"><code>(?i:abc)</code></td><td style="text-align:left;">局部忽略大小写</td><td style="text-align:left;">仅 <code>abc</code></td></tr><tr><td style="text-align:left;"><code>(?-i)</code></td><td style="text-align:left;">关闭忽略大小写</td><td style="text-align:left;">从当前位置起关闭</td></tr><tr><td style="text-align:left;"><code>(?im)</code></td><td style="text-align:left;">同时启用多个修饰符</td><td style="text-align:left;">叠加效果</td></tr><tr><td style="text-align:left;"><code>(?i-mx)</code></td><td style="text-align:left;">启用 <code>i</code>，关闭 <code>m</code>、<code>x</code></td><td style="text-align:left;">可混用正负</td></tr><tr><td style="text-align:left;"><code>(?i:foo)(?v-i:bar)</code></td><td style="text-align:left;">局部切换先忽略大小写匹配 foo 再关闭大小写匹配 bar</td><td style="text-align:left;">不同子模式独立控制</td></tr></tbody></table><ul><li>注意内联修饰符和反向引用的作用范围</li></ul><h2 id="回溯" tabindex="-1"><a class="header-anchor" href="#回溯"><span>回溯</span></a></h2><p>用面包屑比喻就很好理解—如果前面是死路，你只需要沿原路返回，直到找到一堆面包屑为止。</p><p>回溯的原则： 先选择哪个分支？</p><ul><li>贪婪模式尽可能多地匹配，遇到需要回退就回退，非贪婪模式就相反的。 先回溯到哪个分支？</li><li>就近原则</li></ul><p>用面包屑比喻就很好理解—如果前面是死路，你只需要沿原路返回，直到找到一堆面包屑为止</p><p>具体流程请参考:<a href="#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B">正则匹配流程</a></p>',139))])}const b=a(u,[["render",x]]),q=JSON.parse('{"path":"/blog/w83pj83d/","title":"Perl/PCRE 正则表达式","lang":"zh-CN","frontmatter":{"title":"Perl/PCRE 正则表达式","tags":["正则","Perl"],"createTime":"2025/11/01 20:59:57","permalink":"/blog/w83pj83d/"},"readingTime":{"minutes":17.55,"words":5264},"git":{"createdTime":1762188242000,"updatedTime":1762188242000,"contributors":[{"name":"092wb","username":"092wb","email":"150@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/092wb?v=4","url":"https://github.com/092wb"}]},"filePathRelative":"blog/计算机/perl-regex.md","headers":[],"categoryList":[{"id":"8a2b56","sort":10000,"name":"计算机"}]}');export{b as comp,q as data};
